{"ast":null,"code":"/*\n * Copyright (c) 2008-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* CometD Version 4.0.4 */\n(function (root, factory) {\n  var runtime = this['cometdRuntime'];\n\n  if (!runtime) {\n    runtime = window;\n  }\n\n  if (typeof exports === 'object') {\n    // CommonJS.\n    module.exports = factory(runtime);\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD.\n    define([], function () {\n      return factory(runtime);\n    });\n  } else {\n    // Globals.\n    root.org = root.org || {};\n    root.org.cometd = factory(runtime);\n  }\n})(this, function (runtime) {\n  /**\n   * Browsers may throttle the Window scheduler,\n   * so we may replace it with a Worker scheduler.\n   */\n  var Scheduler = function () {\n    var _ids = 0;\n    var _tasks = {};\n\n    this.register = function (funktion) {\n      var id = ++_ids;\n      _tasks[id] = funktion;\n      return id;\n    };\n\n    this.unregister = function (id) {\n      var funktion = _tasks[id];\n      delete _tasks[id];\n      return funktion;\n    };\n\n    this.setTimeout = function (funktion, delay) {\n      return runtime.setTimeout(funktion, delay);\n    };\n\n    this.clearTimeout = function (id) {\n      runtime.clearTimeout(id);\n    };\n  };\n  /**\n   * The scheduler code that will run in the Worker.\n   */\n\n\n  function WorkerScheduler() {\n    var _tasks = {};\n\n    self.onmessage = function (e) {\n      var cmd = e.data;\n      var id = _tasks[cmd.id];\n\n      switch (cmd.type) {\n        case 'setTimeout':\n          _tasks[cmd.id] = self.setTimeout(function () {\n            delete _tasks[cmd.id];\n            self.postMessage({\n              id: cmd.id\n            });\n          }, cmd.delay);\n          break;\n\n        case 'clearTimeout':\n          delete _tasks[cmd.id];\n\n          if (id) {\n            self.clearTimeout(id);\n          }\n\n          break;\n\n        default:\n          throw 'Unknown command ' + cmd.type;\n      }\n    };\n  }\n  /**\n   * Utility functions.\n   */\n\n\n  var Utils = {\n    isString: function (value) {\n      if (value === undefined || value === null) {\n        return false;\n      }\n\n      return typeof value === 'string' || value instanceof String;\n    },\n    isArray: function (value) {\n      if (value === undefined || value === null) {\n        return false;\n      }\n\n      return value instanceof Array;\n    },\n\n    /**\n     * Returns whether the given element is contained into the given array.\n     * @param element the element to check presence for\n     * @param array the array to check for the element presence\n     * @return the index of the element, if present, or a negative index if the element is not present\n     */\n    inArray: function (element, array) {\n      for (var i = 0; i < array.length; ++i) {\n        if (element === array[i]) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  };\n  /**\n   * A registry for transports used by the CometD object.\n   */\n\n  var TransportRegistry = function () {\n    var _types = [];\n    var _transports = {};\n\n    this.getTransportTypes = function () {\n      return _types.slice(0);\n    };\n\n    this.findTransportTypes = function (version, crossDomain, url) {\n      var result = [];\n\n      for (var i = 0; i < _types.length; ++i) {\n        var type = _types[i];\n\n        if (_transports[type].accept(version, crossDomain, url) === true) {\n          result.push(type);\n        }\n      }\n\n      return result;\n    };\n\n    this.negotiateTransport = function (types, version, crossDomain, url) {\n      for (var i = 0; i < _types.length; ++i) {\n        var type = _types[i];\n\n        for (var j = 0; j < types.length; ++j) {\n          if (type === types[j]) {\n            var transport = _transports[type];\n\n            if (transport.accept(version, crossDomain, url) === true) {\n              return transport;\n            }\n          }\n        }\n      }\n\n      return null;\n    };\n\n    this.add = function (type, transport, index) {\n      var existing = false;\n\n      for (var i = 0; i < _types.length; ++i) {\n        if (_types[i] === type) {\n          existing = true;\n          break;\n        }\n      }\n\n      if (!existing) {\n        if (typeof index !== 'number') {\n          _types.push(type);\n        } else {\n          _types.splice(index, 0, type);\n        }\n\n        _transports[type] = transport;\n      }\n\n      return !existing;\n    };\n\n    this.find = function (type) {\n      for (var i = 0; i < _types.length; ++i) {\n        if (_types[i] === type) {\n          return _transports[type];\n        }\n      }\n\n      return null;\n    };\n\n    this.remove = function (type) {\n      for (var i = 0; i < _types.length; ++i) {\n        if (_types[i] === type) {\n          _types.splice(i, 1);\n\n          var transport = _transports[type];\n          delete _transports[type];\n          return transport;\n        }\n      }\n\n      return null;\n    };\n\n    this.clear = function () {\n      _types = [];\n      _transports = {};\n    };\n\n    this.reset = function (init) {\n      for (var i = 0; i < _types.length; ++i) {\n        _transports[_types[i]].reset(init);\n      }\n    };\n  };\n  /**\n   * Base object with the common functionality for transports.\n   */\n\n\n  var Transport = function () {\n    var _type;\n\n    var _cometd;\n\n    var _url;\n    /**\n     * Function invoked just after a transport has been successfully registered.\n     * @param type the type of transport (for example 'long-polling')\n     * @param cometd the cometd object this transport has been registered to\n     * @see #unregistered()\n     */\n\n\n    this.registered = function (type, cometd) {\n      _type = type;\n      _cometd = cometd;\n    };\n    /**\n     * Function invoked just after a transport has been successfully unregistered.\n     * @see #registered(type, cometd)\n     */\n\n\n    this.unregistered = function () {\n      _type = null;\n      _cometd = null;\n    };\n\n    this._debug = function () {\n      _cometd._debug.apply(_cometd, arguments);\n    };\n\n    this._mixin = function () {\n      return _cometd._mixin.apply(_cometd, arguments);\n    };\n\n    this.getConfiguration = function () {\n      return _cometd.getConfiguration();\n    };\n\n    this.getAdvice = function () {\n      return _cometd.getAdvice();\n    };\n\n    this.setTimeout = function (funktion, delay) {\n      return _cometd.setTimeout(funktion, delay);\n    };\n\n    this.clearTimeout = function (id) {\n      _cometd.clearTimeout(id);\n    };\n    /**\n     * Converts the given response into an array of bayeux messages\n     * @param response the response to convert\n     * @return an array of bayeux messages obtained by converting the response\n     */\n\n\n    this.convertToMessages = function (response) {\n      if (Utils.isString(response)) {\n        try {\n          return JSON.parse(response);\n        } catch (x) {\n          this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n\n          throw x;\n        }\n      }\n\n      if (Utils.isArray(response)) {\n        return response;\n      }\n\n      if (response === undefined || response === null) {\n        return [];\n      }\n\n      if (response instanceof Object) {\n        return [response];\n      }\n\n      throw 'Conversion Error ' + response + ', typeof ' + typeof response;\n    };\n    /**\n     * Returns whether this transport can work for the given version and cross domain communication case.\n     * @param version a string indicating the transport version\n     * @param crossDomain a boolean indicating whether the communication is cross domain\n     * @param url the URL to connect to\n     * @return true if this transport can work for the given version and cross domain communication case,\n     * false otherwise\n     */\n\n\n    this.accept = function (version, crossDomain, url) {\n      throw 'Abstract';\n    };\n    /**\n     * Returns the type of this transport.\n     * @see #registered(type, cometd)\n     */\n\n\n    this.getType = function () {\n      return _type;\n    };\n\n    this.getURL = function () {\n      return _url;\n    };\n\n    this.setURL = function (url) {\n      _url = url;\n    };\n\n    this.send = function (envelope, metaConnect) {\n      throw 'Abstract';\n    };\n\n    this.reset = function (init) {\n      this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n    };\n\n    this.abort = function () {\n      this._debug('Transport', _type, 'aborted');\n    };\n\n    this.toString = function () {\n      return this.getType();\n    };\n  };\n\n  Transport.derive = function (baseObject) {\n    function F() {}\n\n    F.prototype = baseObject;\n    return new F();\n  };\n  /**\n   * Base object with the common functionality for transports based on requests.\n   * The key responsibility is to allow at most 2 outstanding requests to the server,\n   * to avoid that requests are sent behind a long poll.\n   * To achieve this, we have one reserved request for the long poll, and all other\n   * requests are serialized one after the other.\n   */\n\n\n  var RequestTransport = function () {\n    var _super = new Transport();\n\n    var _self = Transport.derive(_super);\n\n    var _requestIds = 0;\n    var _metaConnectRequest = null;\n    var _requests = [];\n    var _envelopes = [];\n\n    function _coalesceEnvelopes(envelope) {\n      while (_envelopes.length > 0) {\n        var envelopeAndRequest = _envelopes[0];\n        var newEnvelope = envelopeAndRequest[0];\n        var newRequest = envelopeAndRequest[1];\n\n        if (newEnvelope.url === envelope.url && newEnvelope.sync === envelope.sync) {\n          _envelopes.shift();\n\n          envelope.messages = envelope.messages.concat(newEnvelope.messages);\n\n          this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n\n          continue;\n        }\n\n        break;\n      }\n    }\n\n    function _transportSend(envelope, request) {\n      this.transportSend(envelope, request);\n      request.expired = false;\n\n      if (!envelope.sync) {\n        var maxDelay = this.getConfiguration().maxNetworkDelay;\n        var delay = maxDelay;\n\n        if (request.metaConnect === true) {\n          delay += this.getAdvice().timeout;\n        }\n\n        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\n        var self = this;\n        request.timeout = this.setTimeout(function () {\n          request.expired = true;\n          var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n          var failure = {\n            reason: errorMessage\n          };\n          var xhr = request.xhr;\n          failure.httpCode = self.xhrStatus(xhr);\n          self.abortXHR(xhr);\n\n          self._debug(errorMessage);\n\n          self.complete(request, false, request.metaConnect);\n          envelope.onFailure(xhr, envelope.messages, failure);\n        }, delay);\n      }\n    }\n\n    function _queueSend(envelope) {\n      var requestId = ++_requestIds;\n      var request = {\n        id: requestId,\n        metaConnect: false,\n        envelope: envelope\n      }; // Consider the /meta/connect requests which should always be present.\n\n      if (_requests.length < this.getConfiguration().maxConnections - 1) {\n        _requests.push(request);\n\n        _transportSend.call(this, envelope, request);\n      } else {\n        this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n\n        _envelopes.push([envelope, request]);\n      }\n    }\n\n    function _metaConnectComplete(request) {\n      var requestId = request.id;\n\n      this._debug('Transport', this.getType(), '/meta/connect complete, request', requestId);\n\n      if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n        throw '/meta/connect request mismatch, completing request ' + requestId;\n      }\n\n      _metaConnectRequest = null;\n    }\n\n    function _complete(request, success) {\n      var index = Utils.inArray(request, _requests); // The index can be negative if the request has been aborted\n\n      if (index >= 0) {\n        _requests.splice(index, 1);\n      }\n\n      if (_envelopes.length > 0) {\n        var envelopeAndRequest = _envelopes.shift();\n\n        var nextEnvelope = envelopeAndRequest[0];\n        var nextRequest = envelopeAndRequest[1];\n\n        this._debug('Transport dequeued request', nextRequest.id);\n\n        if (success) {\n          if (this.getConfiguration().autoBatch) {\n            _coalesceEnvelopes.call(this, nextEnvelope);\n          }\n\n          _queueSend.call(this, nextEnvelope);\n\n          this._debug('Transport completed request', request.id, nextEnvelope);\n        } else {\n          // Keep the semantic of calling response callbacks asynchronously after the request\n          var self = this;\n          this.setTimeout(function () {\n            self.complete(nextRequest, false, nextRequest.metaConnect);\n            var failure = {\n              reason: 'Previous request failed'\n            };\n            var xhr = nextRequest.xhr;\n            failure.httpCode = self.xhrStatus(xhr);\n            nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n          }, 0);\n        }\n      }\n    }\n\n    _self.complete = function (request, success, metaConnect) {\n      if (metaConnect) {\n        _metaConnectComplete.call(this, request);\n      } else {\n        _complete.call(this, request, success);\n      }\n    };\n    /**\n     * Performs the actual send depending on the transport type details.\n     * @param envelope the envelope to send\n     * @param request the request information\n     */\n\n\n    _self.transportSend = function (envelope, request) {\n      throw 'Abstract';\n    };\n\n    _self.transportSuccess = function (envelope, request, responses) {\n      if (!request.expired) {\n        this.clearTimeout(request.timeout);\n        this.complete(request, true, request.metaConnect);\n\n        if (responses && responses.length > 0) {\n          envelope.onSuccess(responses);\n        } else {\n          envelope.onFailure(request.xhr, envelope.messages, {\n            httpCode: 204\n          });\n        }\n      }\n    };\n\n    _self.transportFailure = function (envelope, request, failure) {\n      if (!request.expired) {\n        this.clearTimeout(request.timeout);\n        this.complete(request, false, request.metaConnect);\n        envelope.onFailure(request.xhr, envelope.messages, failure);\n      }\n    };\n\n    function _metaConnectSend(envelope) {\n      if (_metaConnectRequest !== null) {\n        throw 'Concurrent /meta/connect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n      }\n\n      var requestId = ++_requestIds;\n\n      this._debug('Transport', this.getType(), '/meta/connect send, request', requestId, 'envelope', envelope);\n\n      var request = {\n        id: requestId,\n        metaConnect: true,\n        envelope: envelope\n      };\n\n      _transportSend.call(this, envelope, request);\n\n      _metaConnectRequest = request;\n    }\n\n    _self.send = function (envelope, metaConnect) {\n      if (metaConnect) {\n        _metaConnectSend.call(this, envelope);\n      } else {\n        _queueSend.call(this, envelope);\n      }\n    };\n\n    _self.abort = function () {\n      _super.abort();\n\n      for (var i = 0; i < _requests.length; ++i) {\n        var request = _requests[i];\n\n        if (request) {\n          this._debug('Aborting request', request);\n\n          if (!this.abortXHR(request.xhr)) {\n            this.transportFailure(request.envelope, request, {\n              reason: 'abort'\n            });\n          }\n        }\n      }\n\n      var metaConnectRequest = _metaConnectRequest;\n\n      if (metaConnectRequest) {\n        this._debug('Aborting /meta/connect request', metaConnectRequest);\n\n        if (!this.abortXHR(metaConnectRequest.xhr)) {\n          this.transportFailure(metaConnectRequest.envelope, metaConnectRequest, {\n            reason: 'abort'\n          });\n        }\n      }\n\n      this.reset(true);\n    };\n\n    _self.reset = function (init) {\n      _super.reset(init);\n\n      _metaConnectRequest = null;\n      _requests = [];\n      _envelopes = [];\n    };\n\n    _self.abortXHR = function (xhr) {\n      if (xhr) {\n        try {\n          var state = xhr.readyState;\n          xhr.abort();\n          return state !== runtime.XMLHttpRequest.UNSENT;\n        } catch (x) {\n          this._debug(x);\n        }\n      }\n\n      return false;\n    };\n\n    _self.xhrStatus = function (xhr) {\n      if (xhr) {\n        try {\n          return xhr.status;\n        } catch (x) {\n          this._debug(x);\n        }\n      }\n\n      return -1;\n    };\n\n    return _self;\n  };\n\n  var LongPollingTransport = function () {\n    var _super = new RequestTransport();\n\n    var _self = Transport.derive(_super); // By default, support cross domain\n\n\n    var _supportsCrossDomain = true;\n\n    _self.accept = function (version, crossDomain, url) {\n      return _supportsCrossDomain || !crossDomain;\n    };\n\n    _self.newXMLHttpRequest = function () {\n      return new runtime.XMLHttpRequest();\n    };\n\n    _self.xhrSend = function (packet) {\n      var xhr = _self.newXMLHttpRequest(); // Copy external context, to be used in other environments.\n\n\n      xhr.context = _self.context;\n      xhr.withCredentials = true;\n      xhr.open('POST', packet.url, packet.sync !== true);\n      var headers = packet.headers;\n\n      if (headers) {\n        for (var headerName in headers) {\n          if (headers.hasOwnProperty(headerName)) {\n            xhr.setRequestHeader(headerName, headers[headerName]);\n          }\n        }\n      }\n\n      xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');\n\n      xhr.onload = function () {\n        if (xhr.status === 200) {\n          packet.onSuccess(xhr.responseText);\n        } else {\n          packet.onError(xhr.statusText);\n        }\n      };\n\n      xhr.onerror = function () {\n        packet.onError(xhr.statusText);\n      };\n\n      xhr.send(packet.body);\n      return xhr;\n    };\n\n    _self.transportSend = function (envelope, request) {\n      this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\n      var self = this;\n\n      try {\n        var sameStack = true;\n        request.xhr = this.xhrSend({\n          transport: this,\n          url: envelope.url,\n          sync: envelope.sync,\n          headers: this.getConfiguration().requestHeaders,\n          body: JSON.stringify(envelope.messages),\n          onSuccess: function (response) {\n            self._debug('Transport', self.getType(), 'received response', response);\n\n            var success = false;\n\n            try {\n              var received = self.convertToMessages(response);\n\n              if (received.length === 0) {\n                _supportsCrossDomain = false;\n                self.transportFailure(envelope, request, {\n                  httpCode: 204\n                });\n              } else {\n                success = true;\n                self.transportSuccess(envelope, request, received);\n              }\n            } catch (x) {\n              self._debug(x);\n\n              if (!success) {\n                _supportsCrossDomain = false;\n                var failure = {\n                  exception: x\n                };\n                failure.httpCode = self.xhrStatus(request.xhr);\n                self.transportFailure(envelope, request, failure);\n              }\n            }\n          },\n          onError: function (reason, exception) {\n            self._debug('Transport', self.getType(), 'received error', reason, exception);\n\n            _supportsCrossDomain = false;\n            var failure = {\n              reason: reason,\n              exception: exception\n            };\n            failure.httpCode = self.xhrStatus(request.xhr);\n\n            if (sameStack) {\n              // Keep the semantic of calling response callbacks asynchronously after the request\n              self.setTimeout(function () {\n                self.transportFailure(envelope, request, failure);\n              }, 0);\n            } else {\n              self.transportFailure(envelope, request, failure);\n            }\n          }\n        });\n        sameStack = false;\n      } catch (x) {\n        _supportsCrossDomain = false; // Keep the semantic of calling response callbacks asynchronously after the request\n\n        this.setTimeout(function () {\n          self.transportFailure(envelope, request, {\n            exception: x\n          });\n        }, 0);\n      }\n    };\n\n    _self.reset = function (init) {\n      _super.reset(init);\n\n      _supportsCrossDomain = true;\n    };\n\n    return _self;\n  };\n\n  var CallbackPollingTransport = function () {\n    var _super = new RequestTransport();\n\n    var _self = Transport.derive(_super);\n\n    var jsonp = 0;\n\n    _self.accept = function (version, crossDomain, url) {\n      return true;\n    };\n\n    _self.jsonpSend = function (packet) {\n      var head = document.getElementsByTagName('head')[0];\n      var script = document.createElement('script');\n      var callbackName = '_cometd_jsonp_' + jsonp++;\n\n      runtime[callbackName] = function (responseText) {\n        head.removeChild(script);\n        delete runtime[callbackName];\n        packet.onSuccess(responseText);\n      };\n\n      var url = packet.url;\n      url += url.indexOf('?') < 0 ? '?' : '&';\n      url += 'jsonp=' + callbackName;\n      url += '&message=' + encodeURIComponent(packet.body);\n      script.src = url;\n      script.async = packet.sync !== true;\n      script.type = 'application/javascript';\n\n      script.onerror = function (e) {\n        packet.onError('jsonp ' + e.type);\n      };\n\n      head.appendChild(script);\n    };\n\n    function _failTransportFn(envelope, request, x) {\n      var self = this;\n      return function () {\n        self.transportFailure(envelope, request, 'error', x);\n      };\n    }\n\n    _self.transportSend = function (envelope, request) {\n      var self = this; // Microsoft Internet Explorer has a 2083 URL max length\n      // We must ensure that we stay within that length\n\n      var start = 0;\n      var length = envelope.messages.length;\n      var lengths = [];\n\n      while (length > 0) {\n        // Encode the messages because all brackets, quotes, commas, colons, etc\n        // present in the JSON will be URL encoded, taking many more characters\n        var json = JSON.stringify(envelope.messages.slice(start, start + length));\n        var urlLength = envelope.url.length + encodeURI(json).length;\n        var maxLength = this.getConfiguration().maxURILength;\n\n        if (urlLength > maxLength) {\n          if (length === 1) {\n            var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' + 'for transport ' + this.getType(); // Keep the semantic of calling response callbacks asynchronously after the request\n\n            this.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);\n            return;\n          }\n\n          --length;\n          continue;\n        }\n\n        lengths.push(length);\n        start += length;\n        length = envelope.messages.length - start;\n      } // Here we are sure that the messages can be sent within the URL limit\n\n\n      var envelopeToSend = envelope;\n\n      if (lengths.length > 1) {\n        var begin = 0;\n        var end = lengths[0];\n\n        this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));\n\n        envelopeToSend = this._mixin(false, {}, envelope);\n        envelopeToSend.messages = envelope.messages.slice(begin, end);\n        envelopeToSend.onSuccess = envelope.onSuccess;\n        envelopeToSend.onFailure = envelope.onFailure;\n\n        for (var i = 1; i < lengths.length; ++i) {\n          var nextEnvelope = this._mixin(false, {}, envelope);\n\n          begin = end;\n          end += lengths[i];\n          nextEnvelope.messages = envelope.messages.slice(begin, end);\n          nextEnvelope.onSuccess = envelope.onSuccess;\n          nextEnvelope.onFailure = envelope.onFailure;\n          this.send(nextEnvelope, request.metaConnect);\n        }\n      }\n\n      this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);\n\n      try {\n        var sameStack = true;\n        this.jsonpSend({\n          transport: this,\n          url: envelopeToSend.url,\n          sync: envelopeToSend.sync,\n          headers: this.getConfiguration().requestHeaders,\n          body: JSON.stringify(envelopeToSend.messages),\n          onSuccess: function (responses) {\n            var success = false;\n\n            try {\n              var received = self.convertToMessages(responses);\n\n              if (received.length === 0) {\n                self.transportFailure(envelopeToSend, request, {\n                  httpCode: 204\n                });\n              } else {\n                success = true;\n                self.transportSuccess(envelopeToSend, request, received);\n              }\n            } catch (x) {\n              self._debug(x);\n\n              if (!success) {\n                self.transportFailure(envelopeToSend, request, {\n                  exception: x\n                });\n              }\n            }\n          },\n          onError: function (reason, exception) {\n            var failure = {\n              reason: reason,\n              exception: exception\n            };\n\n            if (sameStack) {\n              // Keep the semantic of calling response callbacks asynchronously after the request\n              self.setTimeout(function () {\n                self.transportFailure(envelopeToSend, request, failure);\n              }, 0);\n            } else {\n              self.transportFailure(envelopeToSend, request, failure);\n            }\n          }\n        });\n        sameStack = false;\n      } catch (xx) {\n        // Keep the semantic of calling response callbacks asynchronously after the request\n        this.setTimeout(function () {\n          self.transportFailure(envelopeToSend, request, {\n            exception: xx\n          });\n        }, 0);\n      }\n    };\n\n    return _self;\n  };\n\n  var WebSocketTransport = function () {\n    var _super = new Transport();\n\n    var _self = Transport.derive(_super);\n\n    var _cometd; // By default WebSocket is supported\n\n\n    var _webSocketSupported = true; // Whether we were able to establish a WebSocket connection\n\n    var _webSocketConnected = false;\n    var _stickyReconnect = true; // The context contains the envelopes that have been sent\n    // and the timeouts for the messages that have been sent.\n\n    var _context = null;\n    var _connecting = null;\n    var _connected = false;\n    var _successCallback = null;\n\n    _self.reset = function (init) {\n      _super.reset(init);\n\n      _webSocketSupported = true;\n\n      if (init) {\n        _webSocketConnected = false;\n      }\n\n      _stickyReconnect = true;\n      _context = null;\n      _connecting = null;\n      _connected = false;\n    };\n\n    function _forceClose(context, event) {\n      if (context) {\n        this.webSocketClose(context, event.code, event.reason); // Force immediate failure of pending messages to trigger reconnect.\n        // This is needed because the server may not reply to our close()\n        // and therefore the onclose function is never called.\n\n        this.onClose(context, event);\n      }\n    }\n\n    function _sameContext(context) {\n      return context === _connecting || context === _context;\n    }\n\n    function _storeEnvelope(context, envelope, metaConnect) {\n      var messageIds = [];\n\n      for (var i = 0; i < envelope.messages.length; ++i) {\n        var message = envelope.messages[i];\n\n        if (message.id) {\n          messageIds.push(message.id);\n        }\n      }\n\n      context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n\n      this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n    }\n\n    function _websocketConnect(context) {\n      // We may have multiple attempts to open a WebSocket\n      // connection, for example a /meta/connect request that\n      // may take time, along with a user-triggered publish.\n      // Early return if we are already connecting.\n      if (_connecting) {\n        return;\n      } // Mangle the URL, changing the scheme from 'http' to 'ws'.\n\n\n      var url = _cometd.getURL().replace(/^http/, 'ws');\n\n      this._debug('Transport', this.getType(), 'connecting to URL', url);\n\n      try {\n        var protocol = _cometd.getConfiguration().protocol;\n\n        context.webSocket = protocol ? new runtime.WebSocket(url, protocol) : new runtime.WebSocket(url);\n        _connecting = context;\n      } catch (x) {\n        _webSocketSupported = false;\n\n        this._debug('Exception while creating WebSocket object', x);\n\n        throw x;\n      } // By default use sticky reconnects.\n\n\n      _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n      var self = this;\n\n      var connectTimeout = _cometd.getConfiguration().connectTimeout;\n\n      if (connectTimeout > 0) {\n        context.connectTimer = this.setTimeout(function () {\n          _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms'); // The connection was not opened, close anyway.\n\n\n          _forceClose.call(self, context, {\n            code: 1000,\n            reason: 'Connect Timeout'\n          });\n        }, connectTimeout);\n      }\n\n      var onopen = function () {\n        _cometd._debug('WebSocket onopen', context);\n\n        if (context.connectTimer) {\n          self.clearTimeout(context.connectTimer);\n        }\n\n        if (_sameContext(context)) {\n          _connecting = null;\n          _context = context;\n          _webSocketConnected = true;\n          self.onOpen(context);\n        } else {\n          // We have a valid connection already, close this one.\n          _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n\n          _forceClose.call(self, context, {\n            code: 1000,\n            reason: 'Extra Connection'\n          });\n        }\n      }; // This callback is invoked when the server sends the close frame.\n      // The close frame for a connection may arrive *after* another\n      // connection has been opened, so we must make sure that actions\n      // are performed only if it's the same connection.\n\n\n      var onclose = function (event) {\n        event = event || {\n          code: 1000\n        };\n\n        _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\n        if (context.connectTimer) {\n          self.clearTimeout(context.connectTimer);\n        }\n\n        self.onClose(context, event);\n      };\n\n      var onmessage = function (wsMessage) {\n        _cometd._debug('WebSocket onmessage', wsMessage, context);\n\n        self.onMessage(context, wsMessage);\n      };\n\n      context.webSocket.onopen = onopen;\n      context.webSocket.onclose = onclose;\n\n      context.webSocket.onerror = function () {\n        // Clients should call onclose(), but if they do not we do it here for safety.\n        onclose({\n          code: 1000,\n          reason: 'Error'\n        });\n      };\n\n      context.webSocket.onmessage = onmessage;\n\n      this._debug('Transport', this.getType(), 'configured callbacks on', context);\n    }\n\n    function _webSocketSend(context, envelope, metaConnect) {\n      var json = JSON.stringify(envelope.messages);\n      context.webSocket.send(json);\n\n      this._debug('Transport', this.getType(), 'sent', envelope, '/meta/connect =', metaConnect); // Manage the timeout waiting for the response.\n\n\n      var maxDelay = this.getConfiguration().maxNetworkDelay;\n      var delay = maxDelay;\n\n      if (metaConnect) {\n        delay += this.getAdvice().timeout;\n        _connected = true;\n      }\n\n      var self = this;\n      var messageIds = [];\n\n      for (var i = 0; i < envelope.messages.length; ++i) {\n        (function () {\n          var message = envelope.messages[i];\n\n          if (message.id) {\n            messageIds.push(message.id);\n            context.timeouts[message.id] = self.setTimeout(function () {\n              _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n\n              _forceClose.call(self, context, {\n                code: 1000,\n                reason: 'Message Timeout'\n              });\n            }, delay);\n          }\n        })();\n      }\n\n      this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n    }\n\n    _self._notifySuccess = function (fn, messages) {\n      fn.call(this, messages);\n    };\n\n    _self._notifyFailure = function (fn, context, messages, failure) {\n      fn.call(this, context, messages, failure);\n    };\n\n    function _send(context, envelope, metaConnect) {\n      try {\n        if (context === null) {\n          context = _connecting || {\n            envelopes: {},\n            timeouts: {}\n          };\n\n          _storeEnvelope.call(this, context, envelope, metaConnect);\n\n          _websocketConnect.call(this, context);\n        } else {\n          _storeEnvelope.call(this, context, envelope, metaConnect);\n\n          _webSocketSend.call(this, context, envelope, metaConnect);\n        }\n      } catch (x) {\n        // Keep the semantic of calling response callbacks asynchronously after the request.\n        var self = this;\n        this.setTimeout(function () {\n          _forceClose.call(self, context, {\n            code: 1000,\n            reason: 'Exception',\n            exception: x\n          });\n        }, 0);\n      }\n    }\n\n    _self.onOpen = function (context) {\n      var envelopes = context.envelopes;\n\n      this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n\n      for (var key in envelopes) {\n        if (envelopes.hasOwnProperty(key)) {\n          var element = envelopes[key];\n          var envelope = element[0];\n          var metaConnect = element[1]; // Store the success callback, which is independent from the envelope,\n          // so that it can be used to notify arrival of messages.\n\n          _successCallback = envelope.onSuccess;\n\n          _webSocketSend.call(this, context, envelope, metaConnect);\n        }\n      }\n    };\n\n    _self.onMessage = function (context, wsMessage) {\n      this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\n      var close = false;\n      var messages = this.convertToMessages(wsMessage.data);\n      var messageIds = [];\n\n      for (var i = 0; i < messages.length; ++i) {\n        var message = messages[i]; // Detect if the message is a response to a request we made.\n        // If it's a meta message, for sure it's a response; otherwise it's\n        // a publish message and publish responses don't have the data field.\n\n        if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n          if (message.id) {\n            messageIds.push(message.id);\n            var timeout = context.timeouts[message.id];\n\n            if (timeout) {\n              this.clearTimeout(timeout);\n              delete context.timeouts[message.id];\n\n              this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n            }\n          }\n        }\n\n        if ('/meta/connect' === message.channel) {\n          _connected = false;\n        }\n\n        if ('/meta/disconnect' === message.channel && !_connected) {\n          close = true;\n        }\n      } // Remove the envelope corresponding to the messages.\n\n\n      var removed = false;\n      var envelopes = context.envelopes;\n\n      for (var j = 0; j < messageIds.length; ++j) {\n        var id = messageIds[j];\n\n        for (var key in envelopes) {\n          if (envelopes.hasOwnProperty(key)) {\n            var ids = key.split(',');\n            var index = Utils.inArray(id, ids);\n\n            if (index >= 0) {\n              removed = true;\n              ids.splice(index, 1);\n              var envelope = envelopes[key][0];\n              var metaConnect = envelopes[key][1];\n              delete envelopes[key];\n\n              if (ids.length > 0) {\n                envelopes[ids.join(',')] = [envelope, metaConnect];\n              }\n\n              break;\n            }\n          }\n        }\n      }\n\n      if (removed) {\n        this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n      }\n\n      this._notifySuccess(_successCallback, messages);\n\n      if (close) {\n        this.webSocketClose(context, 1000, 'Disconnect');\n      }\n    };\n\n    _self.onClose = function (context, event) {\n      this._debug('Transport', this.getType(), 'closed', context, event);\n\n      if (_sameContext(context)) {\n        // Remember if we were able to connect.\n        // This close event could be due to server shutdown,\n        // and if it restarts we want to try websocket again.\n        _webSocketSupported = _stickyReconnect && _webSocketConnected;\n        _connecting = null;\n        _context = null;\n      }\n\n      var timeouts = context.timeouts;\n      context.timeouts = {};\n\n      for (var id in timeouts) {\n        if (timeouts.hasOwnProperty(id)) {\n          this.clearTimeout(timeouts[id]);\n        }\n      }\n\n      var envelopes = context.envelopes;\n      context.envelopes = {};\n\n      for (var key in envelopes) {\n        if (envelopes.hasOwnProperty(key)) {\n          var envelope = envelopes[key][0];\n          var metaConnect = envelopes[key][1];\n\n          if (metaConnect) {\n            _connected = false;\n          }\n\n          var failure = {\n            websocketCode: event.code,\n            reason: event.reason\n          };\n\n          if (event.exception) {\n            failure.exception = event.exception;\n          }\n\n          this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n        }\n      }\n    };\n\n    _self.registered = function (type, cometd) {\n      _super.registered(type, cometd);\n\n      _cometd = cometd;\n    };\n\n    _self.accept = function (version, crossDomain, url) {\n      this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported); // Using !! to return a boolean (and not the WebSocket object).\n\n\n      return _webSocketSupported && !!runtime.WebSocket && _cometd.websocketEnabled !== false;\n    };\n\n    _self.send = function (envelope, metaConnect) {\n      this._debug('Transport', this.getType(), 'sending', envelope, '/meta/connect =', metaConnect);\n\n      _send.call(this, _context, envelope, metaConnect);\n    };\n\n    _self.webSocketClose = function (context, code, reason) {\n      try {\n        if (context.webSocket) {\n          context.webSocket.close(code, reason);\n        }\n      } catch (x) {\n        this._debug(x);\n      }\n    };\n\n    _self.abort = function () {\n      _super.abort();\n\n      _forceClose.call(this, _context, {\n        code: 1000,\n        reason: 'Abort'\n      });\n\n      this.reset(true);\n    };\n\n    return _self;\n  };\n  /**\n   * The constructor for a CometD object, identified by an optional name.\n   * The default name is the string 'default'.\n   * @param name the optional name of this cometd object\n   */\n\n\n  var CometD = function (name) {\n    var _scheduler = new Scheduler();\n\n    var _cometd = this;\n\n    var _name = name || 'default';\n\n    var _crossDomain = false;\n\n    var _transports = new TransportRegistry();\n\n    var _transport;\n\n    var _status = 'disconnected';\n    var _messageId = 0;\n    var _clientId = null;\n    var _batch = 0;\n    var _messageQueue = [];\n    var _internalBatch = false;\n    var _listenerId = 0;\n    var _listeners = {};\n    var _backoff = 0;\n    var _scheduledSend = null;\n    var _extensions = [];\n    var _advice = {};\n\n    var _handshakeProps;\n\n    var _handshakeCallback;\n\n    var _callbacks = {};\n    var _remoteCalls = {};\n    var _reestablish = false;\n    var _connected = false;\n    var _unconnectTime = 0;\n    var _handshakeMessages = 0;\n    var _metaConnect = null;\n    var _config = {\n      useWorkerScheduler: true,\n      protocol: null,\n      stickyReconnect: true,\n      connectTimeout: 0,\n      maxConnections: 2,\n      backoffIncrement: 1000,\n      maxBackoff: 60000,\n      logLevel: 'info',\n      maxNetworkDelay: 10000,\n      requestHeaders: {},\n      appendMessageTypeToURL: true,\n      autoBatch: false,\n      urls: {},\n      maxURILength: 2000,\n      advice: {\n        timeout: 60000,\n        interval: 0,\n        reconnect: undefined,\n        maxInterval: 0\n      }\n    };\n\n    function _fieldValue(object, name) {\n      try {\n        return object[name];\n      } catch (x) {\n        return undefined;\n      }\n    }\n    /**\n     * Mixes in the given objects into the target object by copying the properties.\n     * @param deep if the copy must be deep\n     * @param target the target object\n     * @param objects the objects whose properties are copied into the target\n     */\n\n\n    this._mixin = function (deep, target, objects) {\n      var result = target || {}; // Skip first 2 parameters (deep and target), and loop over the others\n\n      for (var i = 2; i < arguments.length; ++i) {\n        var object = arguments[i];\n\n        if (object === undefined || object === null) {\n          continue;\n        }\n\n        for (var propName in object) {\n          if (object.hasOwnProperty(propName)) {\n            var prop = _fieldValue(object, propName);\n\n            var targ = _fieldValue(result, propName); // Avoid infinite loops\n\n\n            if (prop === target) {\n              continue;\n            } // Do not mixin undefined values\n\n\n            if (prop === undefined) {\n              continue;\n            }\n\n            if (deep && typeof prop === 'object' && prop !== null) {\n              if (prop instanceof Array) {\n                result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n              } else {\n                var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n                result[propName] = this._mixin(deep, source, prop);\n              }\n            } else {\n              result[propName] = prop;\n            }\n          }\n        }\n      }\n\n      return result;\n    };\n\n    function _isString(value) {\n      return Utils.isString(value);\n    }\n\n    function _isFunction(value) {\n      if (value === undefined || value === null) {\n        return false;\n      }\n\n      return typeof value === 'function';\n    }\n\n    function _zeroPad(value, length) {\n      var result = '';\n\n      while (--length > 0) {\n        if (value >= Math.pow(10, length)) {\n          break;\n        }\n\n        result += '0';\n      }\n\n      result += value;\n      return result;\n    }\n\n    function _log(level, args) {\n      if (runtime.console) {\n        var logger = runtime.console[level];\n\n        if (_isFunction(logger)) {\n          var now = new Date();\n          [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' + _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n          logger.apply(runtime.console, args);\n        }\n      }\n    }\n\n    this._warn = function () {\n      _log('warn', arguments);\n    };\n\n    this._info = function () {\n      if (_config.logLevel !== 'warn') {\n        _log('info', arguments);\n      }\n    };\n\n    this._debug = function () {\n      if (_config.logLevel === 'debug') {\n        _log('debug', arguments);\n      }\n    };\n\n    function _splitURL(url) {\n      // [1] = protocol://,\n      // [2] = host:port,\n      // [3] = host,\n      // [4] = IPv6_host,\n      // [5] = IPv4_host,\n      // [6] = :port,\n      // [7] = port,\n      // [8] = uri,\n      // [9] = rest (query / fragment)\n      return new RegExp('(^https?://)?(((\\\\[[^\\\\]]+])|([^:/?#]+))(:(\\\\d+))?)?([^?#]*)(.*)?').exec(url);\n    }\n    /**\n     * Returns whether the given hostAndPort is cross domain.\n     * The default implementation checks against window.location.host\n     * but this function can be overridden to make it work in non-browser\n     * environments.\n     *\n     * @param hostAndPort the host and port in format host:port\n     * @return whether the given hostAndPort is cross domain\n     */\n\n\n    this._isCrossDomain = function (hostAndPort) {\n      if (runtime.location && runtime.location.host) {\n        if (hostAndPort) {\n          return hostAndPort !== runtime.location.host;\n        }\n      }\n\n      return false;\n    };\n\n    function _configure(configuration) {\n      _cometd._debug('Configuring cometd object with', configuration); // Support old style param, where only the Bayeux server URL was passed.\n\n\n      if (_isString(configuration)) {\n        configuration = {\n          url: configuration\n        };\n      }\n\n      if (!configuration) {\n        configuration = {};\n      }\n\n      _config = _cometd._mixin(false, _config, configuration);\n\n      var url = _cometd.getURL();\n\n      if (!url) {\n        throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n      } // Check if we're cross domain.\n\n\n      var urlParts = _splitURL(url);\n\n      var hostAndPort = urlParts[2];\n      var uri = urlParts[8];\n      var afterURI = urlParts[9];\n      _crossDomain = _cometd._isCrossDomain(hostAndPort); // Check if appending extra path is supported.\n\n      if (_config.appendMessageTypeToURL) {\n        if (afterURI !== undefined && afterURI.length > 0) {\n          _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n\n          _config.appendMessageTypeToURL = false;\n        } else {\n          var uriSegments = uri.split('/');\n          var lastSegmentIndex = uriSegments.length - 1;\n\n          if (uri.match(/\\/$/)) {\n            lastSegmentIndex -= 1;\n          }\n\n          if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n            // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n            // It will be difficult to add the extra path in this case\n            _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n\n            _config.appendMessageTypeToURL = false;\n          }\n        }\n      }\n\n      if (runtime.Worker && runtime.Blob && runtime.URL && _config.useWorkerScheduler) {\n        var code = WorkerScheduler.toString(); // Remove the function declaration, the opening brace and the closing brace.\n\n        code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));\n        var blob = new runtime.Blob([code], {\n          type: 'application/json'\n        });\n        var blobURL = runtime.URL.createObjectURL(blob);\n        var worker = new runtime.Worker(blobURL);\n\n        _scheduler.setTimeout = function (funktion, delay) {\n          var id = _scheduler.register(funktion);\n\n          worker.postMessage({\n            id: id,\n            type: 'setTimeout',\n            delay: delay\n          });\n          return id;\n        };\n\n        _scheduler.clearTimeout = function (id) {\n          _scheduler.unregister(id);\n\n          worker.postMessage({\n            id: id,\n            type: 'clearTimeout'\n          });\n        };\n\n        worker.onmessage = function (e) {\n          var id = e.data.id;\n\n          var funktion = _scheduler.unregister(id);\n\n          if (funktion) {\n            funktion();\n          }\n        };\n      }\n    }\n\n    function _removeListener(subscription) {\n      if (subscription) {\n        var subscriptions = _listeners[subscription.channel];\n\n        if (subscriptions && subscriptions[subscription.id]) {\n          delete subscriptions[subscription.id];\n\n          _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n        }\n      }\n    }\n\n    function _removeSubscription(subscription) {\n      if (subscription && !subscription.listener) {\n        _removeListener(subscription);\n      }\n    }\n\n    function _clearSubscriptions() {\n      for (var channel in _listeners) {\n        if (_listeners.hasOwnProperty(channel)) {\n          var subscriptions = _listeners[channel];\n\n          if (subscriptions) {\n            for (var id in subscriptions) {\n              if (subscriptions.hasOwnProperty(id)) {\n                _removeSubscription(subscriptions[id]);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    function _setStatus(newStatus) {\n      if (_status !== newStatus) {\n        _cometd._debug('Status', _status, '->', newStatus);\n\n        _status = newStatus;\n      }\n    }\n\n    function _isDisconnected() {\n      return _status === 'disconnecting' || _status === 'disconnected';\n    }\n\n    function _nextMessageId() {\n      var result = ++_messageId;\n      return '' + result;\n    }\n\n    function _applyExtension(scope, callback, name, message, outgoing) {\n      try {\n        return callback.call(scope, message);\n      } catch (x) {\n        var handler = _cometd.onExtensionException;\n\n        if (_isFunction(handler)) {\n          _cometd._debug('Invoking extension exception handler', name, x);\n\n          try {\n            handler.call(_cometd, x, name, outgoing, message);\n          } catch (xx) {\n            _cometd._info('Exception during execution of extension exception handler', name, xx);\n          }\n        } else {\n          _cometd._info('Exception during execution of extension', name, x);\n        }\n\n        return message;\n      }\n    }\n\n    function _applyIncomingExtensions(message) {\n      for (var i = 0; i < _extensions.length; ++i) {\n        if (message === undefined || message === null) {\n          break;\n        }\n\n        var extension = _extensions[i];\n        var callback = extension.extension.incoming;\n\n        if (_isFunction(callback)) {\n          var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n\n          message = result === undefined ? message : result;\n        }\n      }\n\n      return message;\n    }\n\n    function _applyOutgoingExtensions(message) {\n      for (var i = _extensions.length - 1; i >= 0; --i) {\n        if (message === undefined || message === null) {\n          break;\n        }\n\n        var extension = _extensions[i];\n        var callback = extension.extension.outgoing;\n\n        if (_isFunction(callback)) {\n          var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n\n          message = result === undefined ? message : result;\n        }\n      }\n\n      return message;\n    }\n\n    function _notify(channel, message) {\n      var subscriptions = _listeners[channel];\n\n      if (subscriptions) {\n        for (var id in subscriptions) {\n          if (subscriptions.hasOwnProperty(id)) {\n            var subscription = subscriptions[id]; // Subscriptions may come and go, so the array may have 'holes'\n\n            if (subscription) {\n              try {\n                subscription.callback.call(subscription.scope, message);\n              } catch (x) {\n                var handler = _cometd.onListenerException;\n\n                if (_isFunction(handler)) {\n                  _cometd._debug('Invoking listener exception handler', subscription, x);\n\n                  try {\n                    handler.call(_cometd, x, subscription, subscription.listener, message);\n                  } catch (xx) {\n                    _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n                  }\n                } else {\n                  _cometd._info('Exception during execution of listener', subscription, message, x);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    function _notifyListeners(channel, message) {\n      // Notify direct listeners\n      _notify(channel, message); // Notify the globbing listeners\n\n\n      var channelParts = channel.split('/');\n      var last = channelParts.length - 1;\n\n      for (var i = last; i > 0; --i) {\n        var channelPart = channelParts.slice(0, i).join('/') + '/*'; // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n        // so we stop at the first non recursive globbing\n\n        if (i === last) {\n          _notify(channelPart, message);\n        } // Add the recursive globber and notify\n\n\n        channelPart += '*';\n\n        _notify(channelPart, message);\n      }\n    }\n\n    function _cancelDelayedSend() {\n      if (_scheduledSend !== null) {\n        _cometd.clearTimeout(_scheduledSend);\n      }\n\n      _scheduledSend = null;\n    }\n\n    function _delayedSend(operation, delay) {\n      _cancelDelayedSend();\n\n      var time = _advice.interval + delay;\n\n      _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n\n      _scheduledSend = _cometd.setTimeout(operation, time);\n    } // Needed to break cyclic dependencies between function definitions\n\n\n    var _handleMessages;\n\n    var _handleFailure;\n    /**\n     * Delivers the messages to the CometD server\n     * @param messages the array of messages to send\n     * @param metaConnect true if this send is on /meta/connect\n     * @param extraPath an extra path to append to the Bayeux server URL\n     */\n\n\n    function _send(messages, metaConnect, extraPath) {\n      // We must be sure that the messages have a clientId.\n      // This is not guaranteed since the handshake may take time to return\n      // (and hence the clientId is not known yet) and the application\n      // may create other messages.\n      for (var i = 0; i < messages.length; ++i) {\n        var message = messages[i];\n        var messageId = message.id;\n\n        if (_clientId) {\n          message.clientId = _clientId;\n        }\n\n        message = _applyOutgoingExtensions(message);\n\n        if (message !== undefined && message !== null) {\n          // Extensions may have modified the message id, but we need to own it.\n          message.id = messageId;\n          messages[i] = message;\n        } else {\n          delete _callbacks[messageId];\n          messages.splice(i--, 1);\n        }\n      }\n\n      if (messages.length === 0) {\n        return;\n      }\n\n      if (metaConnect) {\n        _metaConnect = messages[0];\n      }\n\n      var url = _cometd.getURL();\n\n      if (_config.appendMessageTypeToURL) {\n        // If url does not end with '/', then append it\n        if (!url.match(/\\/$/)) {\n          url = url + '/';\n        }\n\n        if (extraPath) {\n          url = url + extraPath;\n        }\n      }\n\n      var envelope = {\n        url: url,\n        sync: false,\n        messages: messages,\n        onSuccess: function (rcvdMessages) {\n          try {\n            _handleMessages.call(_cometd, rcvdMessages);\n          } catch (x) {\n            _cometd._info('Exception during handling of messages', x);\n          }\n        },\n        onFailure: function (conduit, messages, failure) {\n          try {\n            var transport = _cometd.getTransport();\n\n            failure.connectionType = transport ? transport.getType() : \"unknown\";\n\n            _handleFailure.call(_cometd, conduit, messages, failure);\n          } catch (x) {\n            _cometd._info('Exception during handling of failure', x);\n          }\n        }\n      };\n\n      _cometd._debug('Send', envelope);\n\n      _transport.send(envelope, metaConnect);\n    }\n\n    function _queueSend(message) {\n      if (_batch > 0 || _internalBatch === true) {\n        _messageQueue.push(message);\n      } else {\n        _send([message], false);\n      }\n    }\n    /**\n     * Sends a complete bayeux message.\n     * This method is exposed as a public so that extensions may use it\n     * to send bayeux message directly, for example in case of re-sending\n     * messages that have already been sent but that for some reason must\n     * be resent.\n     */\n\n\n    this.send = _queueSend;\n\n    function _resetBackoff() {\n      _backoff = 0;\n    }\n\n    function _increaseBackoff() {\n      if (_backoff < _config.maxBackoff) {\n        _backoff += _config.backoffIncrement;\n      }\n\n      return _backoff;\n    }\n    /**\n     * Starts a the batch of messages to be sent in a single request.\n     * @see #_endBatch(sendMessages)\n     */\n\n\n    function _startBatch() {\n      ++_batch;\n\n      _cometd._debug('Starting batch, depth', _batch);\n    }\n\n    function _flushBatch() {\n      var messages = _messageQueue;\n      _messageQueue = [];\n\n      if (messages.length > 0) {\n        _send(messages, false);\n      }\n    }\n    /**\n     * Ends the batch of messages to be sent in a single request,\n     * optionally sending messages present in the message queue depending\n     * on the given argument.\n     * @see #_startBatch()\n     */\n\n\n    function _endBatch() {\n      --_batch;\n\n      _cometd._debug('Ending batch, depth', _batch);\n\n      if (_batch < 0) {\n        throw 'Calls to startBatch() and endBatch() are not paired';\n      }\n\n      if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n        _flushBatch();\n      }\n    }\n    /**\n     * Sends the connect message\n     */\n\n\n    function _connect() {\n      if (!_isDisconnected()) {\n        var bayeuxMessage = {\n          id: _nextMessageId(),\n          channel: '/meta/connect',\n          connectionType: _transport.getType()\n        }; // In case of reload or temporary loss of connection\n        // we want the next successful connect to return immediately\n        // instead of being held by the server, so that connect listeners\n        // can be notified that the connection has been re-established\n\n        if (!_connected) {\n          bayeuxMessage.advice = {\n            timeout: 0\n          };\n        }\n\n        _setStatus('connecting');\n\n        _cometd._debug('Connect sent', bayeuxMessage);\n\n        _send([bayeuxMessage], true, 'connect');\n\n        _setStatus('connected');\n      }\n    }\n\n    function _delayedConnect(delay) {\n      _setStatus('connecting');\n\n      _delayedSend(function () {\n        _connect();\n      }, delay);\n    }\n\n    function _updateAdvice(newAdvice) {\n      if (newAdvice) {\n        _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n\n        _cometd._debug('New advice', _advice);\n      }\n    }\n\n    function _disconnect(abort) {\n      _cancelDelayedSend();\n\n      if (abort && _transport) {\n        _transport.abort();\n      }\n\n      _crossDomain = false;\n      _transport = null;\n\n      _setStatus('disconnected');\n\n      _clientId = null;\n      _batch = 0;\n\n      _resetBackoff();\n\n      _reestablish = false;\n      _connected = false;\n      _unconnectTime = 0;\n      _metaConnect = null; // Fail any existing queued message\n\n      if (_messageQueue.length > 0) {\n        var messages = _messageQueue;\n        _messageQueue = [];\n\n        _handleFailure.call(_cometd, undefined, messages, {\n          reason: 'Disconnected'\n        });\n      }\n    }\n\n    function _notifyTransportException(oldTransport, newTransport, failure) {\n      var handler = _cometd.onTransportException;\n\n      if (_isFunction(handler)) {\n        _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n\n        try {\n          handler.call(_cometd, failure, oldTransport, newTransport);\n        } catch (x) {\n          _cometd._info('Exception during execution of transport exception handler', x);\n        }\n      }\n    }\n    /**\n     * Sends the initial handshake message\n     */\n\n\n    function _handshake(handshakeProps, handshakeCallback) {\n      if (_isFunction(handshakeProps)) {\n        handshakeCallback = handshakeProps;\n        handshakeProps = undefined;\n      }\n\n      _clientId = null;\n\n      _clearSubscriptions(); // Reset the transports if we're not retrying the handshake\n\n\n      if (_isDisconnected()) {\n        _transports.reset(true);\n      } // Reset the advice.\n\n\n      _updateAdvice({});\n\n      _batch = 0; // Mark the start of an internal batch.\n      // This is needed because handshake and connect are async.\n      // It may happen that the application calls init() then subscribe()\n      // and the subscribe message is sent before the connect message, if\n      // the subscribe message is not held until the connect message is sent.\n      // So here we start a batch to hold temporarily any message until\n      // the connection is fully established.\n\n      _internalBatch = true; // Save the properties provided by the user, so that\n      // we can reuse them during automatic re-handshake\n\n      _handshakeProps = handshakeProps;\n      _handshakeCallback = handshakeCallback;\n      var version = '1.0'; // Figure out the transports to send to the server\n\n      var url = _cometd.getURL();\n\n      var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n      var bayeuxMessage = {\n        id: _nextMessageId(),\n        version: version,\n        minimumVersion: version,\n        channel: '/meta/handshake',\n        supportedConnectionTypes: transportTypes,\n        advice: {\n          timeout: _advice.timeout,\n          interval: _advice.interval\n        }\n      }; // Do not allow the user to override important fields.\n\n      var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage); // Save the callback.\n\n\n      _cometd._putCallback(message.id, handshakeCallback); // Pick up the first available transport as initial transport\n      // since we don't know if the server supports it\n\n\n      if (!_transport) {\n        _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n\n        if (!_transport) {\n          var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n\n          _cometd._warn(failure);\n\n          throw failure;\n        }\n      }\n\n      _cometd._debug('Initial transport is', _transport.getType()); // We started a batch to hold the application messages,\n      // so here we must bypass it and send immediately.\n\n\n      _setStatus('handshaking');\n\n      _cometd._debug('Handshake sent', message);\n\n      _send([message], false, 'handshake');\n    }\n\n    function _delayedHandshake(delay) {\n      _setStatus('handshaking'); // We will call _handshake() which will reset _clientId, but we want to avoid\n      // that between the end of this method and the call to _handshake() someone may\n      // call publish() (or other methods that call _queueSend()).\n\n\n      _internalBatch = true;\n\n      _delayedSend(function () {\n        _handshake(_handshakeProps, _handshakeCallback);\n      }, delay);\n    }\n\n    function _notifyCallback(callback, message) {\n      try {\n        callback.call(_cometd, message);\n      } catch (x) {\n        var handler = _cometd.onCallbackException;\n\n        if (_isFunction(handler)) {\n          _cometd._debug('Invoking callback exception handler', x);\n\n          try {\n            handler.call(_cometd, x, message);\n          } catch (xx) {\n            _cometd._info('Exception during execution of callback exception handler', xx);\n          }\n        } else {\n          _cometd._info('Exception during execution of message callback', x);\n        }\n      }\n    }\n\n    this._getCallback = function (messageId) {\n      return _callbacks[messageId];\n    };\n\n    this._putCallback = function (messageId, callback) {\n      var result = this._getCallback(messageId);\n\n      if (_isFunction(callback)) {\n        _callbacks[messageId] = callback;\n      }\n\n      return result;\n    };\n\n    function _handleCallback(message) {\n      var callback = _cometd._getCallback([message.id]);\n\n      if (_isFunction(callback)) {\n        delete _callbacks[message.id];\n\n        _notifyCallback(callback, message);\n      }\n    }\n\n    function _handleRemoteCall(message) {\n      var context = _remoteCalls[message.id];\n      delete _remoteCalls[message.id];\n\n      if (context) {\n        _cometd._debug('Handling remote call response for', message, 'with context', context); // Clear the timeout, if present.\n\n\n        var timeout = context.timeout;\n\n        if (timeout) {\n          _cometd.clearTimeout(timeout);\n        }\n\n        var callback = context.callback;\n\n        if (_isFunction(callback)) {\n          _notifyCallback(callback, message);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this.onTransportFailure = function (message, failureInfo, failureHandler) {\n      this._debug('Transport failure', failureInfo, 'for', message);\n\n      var transports = this.getTransportRegistry();\n      var url = this.getURL();\n\n      var crossDomain = this._isCrossDomain(_splitURL(url)[2]);\n\n      var version = '1.0';\n      var transportTypes = transports.findTransportTypes(version, crossDomain, url);\n\n      if (failureInfo.action === 'none') {\n        if (message.channel === '/meta/handshake') {\n          if (!failureInfo.transport) {\n            var failure = 'Could not negotiate transport, client=[' + transportTypes + '], server=[' + message.supportedConnectionTypes + ']';\n\n            this._warn(failure);\n\n            _notifyTransportException(_transport.getType(), null, {\n              reason: failure,\n              connectionType: _transport.getType(),\n              transport: _transport\n            });\n          }\n        }\n      } else {\n        failureInfo.delay = this.getBackoffPeriod(); // Different logic depending on whether we are handshaking or connecting.\n\n        if (message.channel === '/meta/handshake') {\n          if (!failureInfo.transport) {\n            // The transport is invalid, try to negotiate again.\n            var newTransport = transports.negotiateTransport(transportTypes, version, crossDomain, url);\n\n            if (!newTransport) {\n              this._warn('Could not negotiate transport, client=[' + transportTypes + ']');\n\n              _notifyTransportException(_transport.getType(), null, message.failure);\n\n              failureInfo.action = 'none';\n            } else {\n              this._debug('Transport', _transport.getType(), '->', newTransport.getType());\n\n              _notifyTransportException(_transport.getType(), newTransport.getType(), message.failure);\n\n              failureInfo.action = 'handshake';\n              failureInfo.transport = newTransport;\n            }\n          }\n\n          if (failureInfo.action !== 'none') {\n            this.increaseBackoffPeriod();\n          }\n        } else {\n          var now = new Date().getTime();\n\n          if (_unconnectTime === 0) {\n            _unconnectTime = now;\n          }\n\n          if (failureInfo.action === 'retry') {\n            failureInfo.delay = this.increaseBackoffPeriod(); // Check whether we may switch to handshaking.\n\n            var maxInterval = _advice.maxInterval;\n\n            if (maxInterval > 0) {\n              var expiration = _advice.timeout + _advice.interval + maxInterval;\n              var unconnected = now - _unconnectTime;\n\n              if (unconnected + _backoff > expiration) {\n                failureInfo.action = 'handshake';\n              }\n            }\n          }\n\n          if (failureInfo.action === 'handshake') {\n            failureInfo.delay = 0;\n            transports.reset(false);\n            this.resetBackoffPeriod();\n          }\n        }\n      }\n\n      failureHandler.call(_cometd, failureInfo);\n    };\n\n    function _handleTransportFailure(failureInfo) {\n      _cometd._debug('Transport failure handling', failureInfo);\n\n      if (failureInfo.transport) {\n        _transport = failureInfo.transport;\n      }\n\n      if (failureInfo.url) {\n        _transport.setURL(failureInfo.url);\n      }\n\n      var action = failureInfo.action;\n      var delay = failureInfo.delay || 0;\n\n      switch (action) {\n        case 'handshake':\n          _delayedHandshake(delay);\n\n          break;\n\n        case 'retry':\n          _delayedConnect(delay);\n\n          break;\n\n        case 'none':\n          _disconnect(true);\n\n          break;\n\n        default:\n          throw 'Unknown action ' + action;\n      }\n    }\n\n    function _failHandshake(message, failureInfo) {\n      _handleCallback(message);\n\n      _notifyListeners('/meta/handshake', message);\n\n      _notifyListeners('/meta/unsuccessful', message); // The listeners may have disconnected.\n\n\n      if (_isDisconnected()) {\n        failureInfo.action = 'none';\n      }\n\n      _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);\n    }\n\n    function _handshakeResponse(message) {\n      var url = _cometd.getURL();\n\n      if (message.successful) {\n        var crossDomain = _cometd._isCrossDomain(_splitURL(url)[2]);\n\n        var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, crossDomain, url);\n\n        if (newTransport === null) {\n          message.successful = false;\n\n          _failHandshake(message, {\n            cause: 'negotiation',\n            action: 'none',\n            transport: null\n          });\n\n          return;\n        } else if (_transport !== newTransport) {\n          _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n\n          _transport = newTransport;\n        }\n\n        _clientId = message.clientId; // End the internal batch and allow held messages from the application\n        // to go to the server (see _handshake() where we start the internal batch).\n\n        _internalBatch = false;\n\n        _flushBatch(); // Here the new transport is in place, as well as the clientId, so\n        // the listeners can perform a publish() if they want.\n        // Notify the listeners before the connect below.\n\n\n        message.reestablish = _reestablish;\n        _reestablish = true;\n\n        _handleCallback(message);\n\n        _notifyListeners('/meta/handshake', message);\n\n        _handshakeMessages = message['x-messages'] || 0;\n        var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';\n\n        switch (action) {\n          case 'retry':\n            _resetBackoff();\n\n            if (_handshakeMessages === 0) {\n              _delayedConnect(0);\n            } else {\n              _cometd._debug('Processing', _handshakeMessages, 'handshake-delivered messages');\n            }\n\n            break;\n\n          case 'none':\n            _disconnect(true);\n\n            break;\n\n          default:\n            throw 'Unrecognized advice action ' + action;\n        }\n      } else {\n        _failHandshake(message, {\n          cause: 'unsuccessful',\n          action: _advice.reconnect || 'handshake',\n          transport: _transport\n        });\n      }\n    }\n\n    function _handshakeFailure(message) {\n      _failHandshake(message, {\n        cause: 'failure',\n        action: 'handshake',\n        transport: null\n      });\n    }\n\n    function _matchMetaConnect(connect) {\n      if (_status === 'disconnected') {\n        return true;\n      }\n\n      if (_metaConnect && _metaConnect.id === connect.id) {\n        _metaConnect = null;\n        return true;\n      }\n\n      return false;\n    }\n\n    function _failConnect(message, failureInfo) {\n      // Notify the listeners after the status change but before the next action.\n      _notifyListeners('/meta/connect', message);\n\n      _notifyListeners('/meta/unsuccessful', message); // The listeners may have disconnected.\n\n\n      if (_isDisconnected()) {\n        failureInfo.action = 'none';\n      }\n\n      _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);\n    }\n\n    function _connectResponse(message) {\n      if (_matchMetaConnect(message)) {\n        _connected = message.successful;\n\n        if (_connected) {\n          _notifyListeners('/meta/connect', message); // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n          // and the server will hold the request, so when a response returns\n          // we immediately call the server again (long polling).\n          // Listeners can call disconnect(), so check the state after they run.\n\n\n          var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';\n\n          switch (action) {\n            case 'retry':\n              _resetBackoff();\n\n              _delayedConnect(_backoff);\n\n              break;\n\n            case 'none':\n              _disconnect(false);\n\n              break;\n\n            default:\n              throw 'Unrecognized advice action ' + action;\n          }\n        } else {\n          _failConnect(message, {\n            cause: 'unsuccessful',\n            action: _advice.reconnect || 'retry',\n            transport: _transport\n          });\n        }\n      } else {\n        _cometd._debug('Mismatched /meta/connect reply', message);\n      }\n    }\n\n    function _connectFailure(message) {\n      if (_matchMetaConnect(message)) {\n        _connected = false;\n\n        _failConnect(message, {\n          cause: 'failure',\n          action: 'retry',\n          transport: null\n        });\n      } else {\n        _cometd._debug('Mismatched /meta/connect failure', message);\n      }\n    }\n\n    function _failDisconnect(message) {\n      _disconnect(true);\n\n      _handleCallback(message);\n\n      _notifyListeners('/meta/disconnect', message);\n\n      _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _disconnectResponse(message) {\n      if (message.successful) {\n        // Wait for the /meta/connect to arrive.\n        _disconnect(false);\n\n        _handleCallback(message);\n\n        _notifyListeners('/meta/disconnect', message);\n      } else {\n        _failDisconnect(message);\n      }\n    }\n\n    function _disconnectFailure(message) {\n      _failDisconnect(message);\n    }\n\n    function _failSubscribe(message) {\n      var subscriptions = _listeners[message.subscription];\n\n      if (subscriptions) {\n        for (var id in subscriptions) {\n          if (subscriptions.hasOwnProperty(id)) {\n            var subscription = subscriptions[id];\n\n            if (subscription && !subscription.listener) {\n              delete subscriptions[id];\n\n              _cometd._debug('Removed failed subscription', subscription);\n            }\n          }\n        }\n      }\n\n      _handleCallback(message);\n\n      _notifyListeners('/meta/subscribe', message);\n\n      _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _subscribeResponse(message) {\n      if (message.successful) {\n        _handleCallback(message);\n\n        _notifyListeners('/meta/subscribe', message);\n      } else {\n        _failSubscribe(message);\n      }\n    }\n\n    function _subscribeFailure(message) {\n      _failSubscribe(message);\n    }\n\n    function _failUnsubscribe(message) {\n      _handleCallback(message);\n\n      _notifyListeners('/meta/unsubscribe', message);\n\n      _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _unsubscribeResponse(message) {\n      if (message.successful) {\n        _handleCallback(message);\n\n        _notifyListeners('/meta/unsubscribe', message);\n      } else {\n        _failUnsubscribe(message);\n      }\n    }\n\n    function _unsubscribeFailure(message) {\n      _failUnsubscribe(message);\n    }\n\n    function _failMessage(message) {\n      if (!_handleRemoteCall(message)) {\n        _handleCallback(message);\n\n        _notifyListeners('/meta/publish', message);\n\n        _notifyListeners('/meta/unsuccessful', message);\n      }\n    }\n\n    function _messageResponse(message) {\n      if (message.data !== undefined) {\n        if (!_handleRemoteCall(message)) {\n          _notifyListeners(message.channel, message);\n\n          if (_handshakeMessages > 0) {\n            --_handshakeMessages;\n\n            if (_handshakeMessages === 0) {\n              _cometd._debug('Processed last handshake-delivered message');\n\n              _delayedConnect(0);\n            }\n          }\n        }\n      } else {\n        if (message.successful === undefined) {\n          _cometd._warn('Unknown Bayeux Message', message);\n        } else {\n          if (message.successful) {\n            _handleCallback(message);\n\n            _notifyListeners('/meta/publish', message);\n          } else {\n            _failMessage(message);\n          }\n        }\n      }\n    }\n\n    function _messageFailure(failure) {\n      _failMessage(failure);\n    }\n\n    function _receive(message) {\n      _unconnectTime = 0;\n      message = _applyIncomingExtensions(message);\n\n      if (message === undefined || message === null) {\n        return;\n      }\n\n      _updateAdvice(message.advice);\n\n      var channel = message.channel;\n\n      switch (channel) {\n        case '/meta/handshake':\n          _handshakeResponse(message);\n\n          break;\n\n        case '/meta/connect':\n          _connectResponse(message);\n\n          break;\n\n        case '/meta/disconnect':\n          _disconnectResponse(message);\n\n          break;\n\n        case '/meta/subscribe':\n          _subscribeResponse(message);\n\n          break;\n\n        case '/meta/unsubscribe':\n          _unsubscribeResponse(message);\n\n          break;\n\n        default:\n          _messageResponse(message);\n\n          break;\n      }\n    }\n    /**\n     * Receives a message.\n     * This method is exposed as a public so that extensions may inject\n     * messages simulating that they had been received.\n     */\n\n\n    this.receive = _receive;\n\n    _handleMessages = function (rcvdMessages) {\n      _cometd._debug('Received', rcvdMessages);\n\n      for (var i = 0; i < rcvdMessages.length; ++i) {\n        var message = rcvdMessages[i];\n\n        _receive(message);\n      }\n    };\n\n    _handleFailure = function (conduit, messages, failure) {\n      _cometd._debug('handleFailure', conduit, messages, failure);\n\n      failure.transport = conduit;\n\n      for (var i = 0; i < messages.length; ++i) {\n        var message = messages[i];\n        var failureMessage = {\n          id: message.id,\n          successful: false,\n          channel: message.channel,\n          failure: failure\n        };\n        failure.message = message;\n\n        switch (message.channel) {\n          case '/meta/handshake':\n            _handshakeFailure(failureMessage);\n\n            break;\n\n          case '/meta/connect':\n            _connectFailure(failureMessage);\n\n            break;\n\n          case '/meta/disconnect':\n            _disconnectFailure(failureMessage);\n\n            break;\n\n          case '/meta/subscribe':\n            failureMessage.subscription = message.subscription;\n\n            _subscribeFailure(failureMessage);\n\n            break;\n\n          case '/meta/unsubscribe':\n            failureMessage.subscription = message.subscription;\n\n            _unsubscribeFailure(failureMessage);\n\n            break;\n\n          default:\n            _messageFailure(failureMessage);\n\n            break;\n        }\n      }\n    };\n\n    function _hasSubscriptions(channel) {\n      var subscriptions = _listeners[channel];\n\n      if (subscriptions) {\n        for (var id in subscriptions) {\n          if (subscriptions.hasOwnProperty(id)) {\n            if (subscriptions[id]) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    function _resolveScopedCallback(scope, callback) {\n      var delegate = {\n        scope: scope,\n        method: callback\n      };\n\n      if (_isFunction(scope)) {\n        delegate.scope = undefined;\n        delegate.method = scope;\n      } else {\n        if (_isString(callback)) {\n          if (!scope) {\n            throw 'Invalid scope ' + scope;\n          }\n\n          delegate.method = scope[callback];\n\n          if (!_isFunction(delegate.method)) {\n            throw 'Invalid callback ' + callback + ' for scope ' + scope;\n          }\n        } else if (!_isFunction(callback)) {\n          throw 'Invalid callback ' + callback;\n        }\n      }\n\n      return delegate;\n    }\n\n    function _addListener(channel, scope, callback, isListener) {\n      // The data structure is a map<channel, subscription[]>, where each subscription\n      // holds the callback to be called and its scope.\n      var delegate = _resolveScopedCallback(scope, callback);\n\n      _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\n      var id = ++_listenerId;\n      var subscription = {\n        id: id,\n        channel: channel,\n        scope: delegate.scope,\n        callback: delegate.method,\n        listener: isListener\n      };\n      var subscriptions = _listeners[channel];\n\n      if (!subscriptions) {\n        subscriptions = {};\n        _listeners[channel] = subscriptions;\n      }\n\n      subscriptions[id] = subscription;\n\n      _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\n      return subscription;\n    } //\n    // PUBLIC API\n    //\n\n    /**\n     * Registers the given transport under the given transport type.\n     * The optional index parameter specifies the \"priority\" at which the\n     * transport is registered (where 0 is the max priority).\n     * If a transport with the same type is already registered, this function\n     * does nothing and returns false.\n     * @param type the transport type\n     * @param transport the transport object\n     * @param index the index at which this transport is to be registered\n     * @return true if the transport has been registered, false otherwise\n     * @see #unregisterTransport(type)\n     */\n\n\n    this.registerTransport = function (type, transport, index) {\n      var result = _transports.add(type, transport, index);\n\n      if (result) {\n        this._debug('Registered transport', type);\n\n        if (_isFunction(transport.registered)) {\n          transport.registered(type, this);\n        }\n      }\n\n      return result;\n    };\n    /**\n     * Unregisters the transport with the given transport type.\n     * @param type the transport type to unregister\n     * @return the transport that has been unregistered,\n     * or null if no transport was previously registered under the given transport type\n     */\n\n\n    this.unregisterTransport = function (type) {\n      var transport = _transports.remove(type);\n\n      if (transport !== null) {\n        this._debug('Unregistered transport', type);\n\n        if (_isFunction(transport.unregistered)) {\n          transport.unregistered();\n        }\n      }\n\n      return transport;\n    };\n\n    this.unregisterTransports = function () {\n      _transports.clear();\n    };\n    /**\n     * @return an array of all registered transport types\n     */\n\n\n    this.getTransportTypes = function () {\n      return _transports.getTransportTypes();\n    };\n\n    this.findTransport = function (name) {\n      return _transports.find(name);\n    };\n    /**\n     * @returns the TransportRegistry object\n     */\n\n\n    this.getTransportRegistry = function () {\n      return _transports;\n    };\n    /**\n     * Configures the initial Bayeux communication with the Bayeux server.\n     * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n     * of type string containing the URL of the Bayeux server.\n     * @param configuration the configuration object\n     */\n\n\n    this.configure = function (configuration) {\n      _configure.call(this, configuration);\n    };\n    /**\n     * Configures and establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param configuration the configuration object\n     * @param handshakeProps an object to be merged with the handshake message\n     * @see #configure(configuration)\n     * @see #handshake(handshakeProps)\n     */\n\n\n    this.init = function (configuration, handshakeProps) {\n      this.configure(configuration);\n      this.handshake(handshakeProps);\n    };\n    /**\n     * Establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param handshakeProps an object to be merged with the handshake message\n     * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n     */\n\n\n    this.handshake = function (handshakeProps, handshakeCallback) {\n      if (_status !== 'disconnected') {\n        throw 'Illegal state: handshaken';\n      }\n\n      _handshake(handshakeProps, handshakeCallback);\n    };\n    /**\n     * Disconnects from the Bayeux server.\n     * @param disconnectProps an object to be merged with the disconnect message\n     * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n     */\n\n\n    this.disconnect = function (disconnectProps, disconnectCallback) {\n      if (_isDisconnected()) {\n        return;\n      }\n\n      if (_isFunction(disconnectProps)) {\n        disconnectCallback = disconnectProps;\n        disconnectProps = undefined;\n      }\n\n      var bayeuxMessage = {\n        id: _nextMessageId(),\n        channel: '/meta/disconnect'\n      }; // Do not allow the user to override important fields.\n\n      var message = this._mixin(false, {}, disconnectProps, bayeuxMessage); // Save the callback.\n\n\n      _cometd._putCallback(message.id, disconnectCallback);\n\n      _setStatus('disconnecting');\n\n      _send([message], false, 'disconnect');\n    };\n    /**\n     * Marks the start of a batch of application messages to be sent to the server\n     * in a single request, obtaining a single response containing (possibly) many\n     * application reply messages.\n     * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n     * If startBatch() is called multiple times, then an equal number of endBatch()\n     * calls must be made to close and send the batch of messages.\n     * @see #endBatch()\n     */\n\n\n    this.startBatch = function () {\n      _startBatch();\n    };\n    /**\n     * Marks the end of a batch of application messages to be sent to the server\n     * in a single request.\n     * @see #startBatch()\n     */\n\n\n    this.endBatch = function () {\n      _endBatch();\n    };\n    /**\n     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n     * and {@link #endBatch()} calls.\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n     */\n\n\n    this.batch = function (scope, callback) {\n      var delegate = _resolveScopedCallback(scope, callback);\n\n      this.startBatch();\n\n      try {\n        delegate.method.call(delegate.scope);\n        this.endBatch();\n      } catch (x) {\n        this._info('Exception during execution of batch', x);\n\n        this.endBatch();\n        throw x;\n      }\n    };\n    /**\n     * Adds a listener for bayeux messages, performing the given callback in the given scope\n     * when a message for the given channel arrives.\n     * @param channel the channel the listener is interested to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @returns the subscription handle to be passed to {@link #removeListener(object)}\n     * @see #removeListener(subscription)\n     */\n\n\n    this.addListener = function (channel, scope, callback) {\n      if (arguments.length < 2) {\n        throw 'Illegal arguments number: required 2, got ' + arguments.length;\n      }\n\n      if (!_isString(channel)) {\n        throw 'Illegal argument type: channel must be a string';\n      }\n\n      return _addListener(channel, scope, callback, true);\n    };\n    /**\n     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @see #addListener(channel, scope, callback)\n     */\n\n\n    this.removeListener = function (subscription) {\n      // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n      if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n        throw 'Invalid argument: expected subscription, not ' + subscription;\n      }\n\n      _removeListener(subscription);\n    };\n    /**\n     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n     * {@link #subscribe(channel, scope, callback)}.\n     */\n\n\n    this.clearListeners = function () {\n      _listeners = {};\n    };\n    /**\n     * Subscribes to the given channel, performing the given callback in the given scope\n     * when a message for the channel arrives.\n     * @param channel the channel to subscribe to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @param subscribeProps an object to be merged with the subscribe message\n     * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n     * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n     */\n\n\n    this.subscribe = function (channel, scope, callback, subscribeProps, subscribeCallback) {\n      if (arguments.length < 2) {\n        throw 'Illegal arguments number: required 2, got ' + arguments.length;\n      }\n\n      if (!_isString(channel)) {\n        throw 'Illegal argument type: channel must be a string';\n      }\n\n      if (_isDisconnected()) {\n        throw 'Illegal state: disconnected';\n      } // Normalize arguments\n\n\n      if (_isFunction(scope)) {\n        subscribeCallback = subscribeProps;\n        subscribeProps = callback;\n        callback = scope;\n        scope = undefined;\n      }\n\n      if (_isFunction(subscribeProps)) {\n        subscribeCallback = subscribeProps;\n        subscribeProps = undefined;\n      } // Only send the message to the server if this client has not yet subscribed to the channel\n\n\n      var send = !_hasSubscriptions(channel);\n\n      var subscription = _addListener(channel, scope, callback, false);\n\n      if (send) {\n        // Send the subscription message after the subscription registration to avoid\n        // races where the server would send a message to the subscribers, but here\n        // on the client the subscription has not been added yet to the data structures\n        var bayeuxMessage = {\n          id: _nextMessageId(),\n          channel: '/meta/subscribe',\n          subscription: channel\n        }; // Do not allow the user to override important fields.\n\n        var message = this._mixin(false, {}, subscribeProps, bayeuxMessage); // Save the callback.\n\n\n        _cometd._putCallback(message.id, subscribeCallback);\n\n        _queueSend(message);\n      }\n\n      return subscription;\n    };\n    /**\n     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @param unsubscribeProps an object to be merged with the unsubscribe message\n     * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n     */\n\n\n    this.unsubscribe = function (subscription, unsubscribeProps, unsubscribeCallback) {\n      if (arguments.length < 1) {\n        throw 'Illegal arguments number: required 1, got ' + arguments.length;\n      }\n\n      if (_isDisconnected()) {\n        throw 'Illegal state: disconnected';\n      }\n\n      if (_isFunction(unsubscribeProps)) {\n        unsubscribeCallback = unsubscribeProps;\n        unsubscribeProps = undefined;\n      } // Remove the local listener before sending the message\n      // This ensures that if the server fails, this client does not get notifications\n\n\n      this.removeListener(subscription);\n      var channel = subscription.channel; // Only send the message to the server if this client unsubscribes the last subscription\n\n      if (!_hasSubscriptions(channel)) {\n        var bayeuxMessage = {\n          id: _nextMessageId(),\n          channel: '/meta/unsubscribe',\n          subscription: channel\n        }; // Do not allow the user to override important fields.\n\n        var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage); // Save the callback.\n\n\n        _cometd._putCallback(message.id, unsubscribeCallback);\n\n        _queueSend(message);\n      }\n    };\n\n    this.resubscribe = function (subscription, subscribeProps) {\n      _removeSubscription(subscription);\n\n      if (subscription) {\n        return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n      }\n\n      return undefined;\n    };\n    /**\n     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n     */\n\n\n    this.clearSubscriptions = function () {\n      _clearSubscriptions();\n    };\n    /**\n     * Publishes a message on the given channel, containing the given content.\n     * @param channel the channel to publish the message to\n     * @param content the content of the message\n     * @param publishProps an object to be merged with the publish message\n     * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n     */\n\n\n    this.publish = function (channel, content, publishProps, publishCallback) {\n      if (arguments.length < 1) {\n        throw 'Illegal arguments number: required 1, got ' + arguments.length;\n      }\n\n      if (!_isString(channel)) {\n        throw 'Illegal argument type: channel must be a string';\n      }\n\n      if (/^\\/meta\\//.test(channel)) {\n        throw 'Illegal argument: cannot publish to meta channels';\n      }\n\n      if (_isDisconnected()) {\n        throw 'Illegal state: disconnected';\n      }\n\n      if (_isFunction(content)) {\n        publishCallback = content;\n        content = {};\n        publishProps = undefined;\n      } else if (_isFunction(publishProps)) {\n        publishCallback = publishProps;\n        publishProps = undefined;\n      }\n\n      var bayeuxMessage = {\n        id: _nextMessageId(),\n        channel: channel,\n        data: content\n      }; // Do not allow the user to override important fields.\n\n      var message = this._mixin(false, {}, publishProps, bayeuxMessage); // Save the callback.\n\n\n      _cometd._putCallback(message.id, publishCallback);\n\n      _queueSend(message);\n    };\n    /**\n     * Publishes a message with binary data on the given channel.\n     * The binary data chunk may be an ArrayBuffer, a DataView, a TypedArray\n     * (such as Uint8Array) or a plain integer array.\n     * The meta data object may contain additional application data such as\n     * a file name, a mime type, etc.\n     * @param channel the channel to publish the message to\n     * @param data the binary data to publish\n     * @param last whether the binary data chunk is the last\n     * @param meta an object containing meta data associated to the binary chunk\n     * @param callback a function to be invoked when the publish is acknowledged by the server\n     */\n\n\n    this.publishBinary = function (channel, data, last, meta, callback) {\n      if (_isFunction(data)) {\n        callback = data;\n        data = new ArrayBuffer(0);\n        last = true;\n        meta = undefined;\n      } else if (_isFunction(last)) {\n        callback = last;\n        last = true;\n        meta = undefined;\n      } else if (_isFunction(meta)) {\n        callback = meta;\n        meta = undefined;\n      }\n\n      var content = {\n        meta: meta,\n        data: data,\n        last: last\n      };\n      var ext = {\n        ext: {\n          binary: {}\n        }\n      };\n      this.publish(channel, content, ext, callback);\n    };\n\n    this.remoteCall = function (target, content, timeout, callProps, callback) {\n      if (arguments.length < 1) {\n        throw 'Illegal arguments number: required 1, got ' + arguments.length;\n      }\n\n      if (!_isString(target)) {\n        throw 'Illegal argument type: target must be a string';\n      }\n\n      if (_isDisconnected()) {\n        throw 'Illegal state: disconnected';\n      }\n\n      if (_isFunction(content)) {\n        callback = content;\n        content = {};\n        timeout = _config.maxNetworkDelay;\n        callProps = undefined;\n      } else if (_isFunction(timeout)) {\n        callback = timeout;\n        timeout = _config.maxNetworkDelay;\n        callProps = undefined;\n      } else if (_isFunction(callProps)) {\n        callback = callProps;\n        callProps = undefined;\n      }\n\n      if (typeof timeout !== 'number') {\n        throw 'Illegal argument type: timeout must be a number';\n      }\n\n      if (!target.match(/^\\//)) {\n        target = '/' + target;\n      }\n\n      var channel = '/service' + target;\n      var bayeuxMessage = {\n        id: _nextMessageId(),\n        channel: channel,\n        data: content\n      };\n\n      var message = this._mixin(false, {}, callProps, bayeuxMessage);\n\n      var context = {\n        callback: callback\n      };\n\n      if (timeout > 0) {\n        context.timeout = _cometd.setTimeout(function () {\n          _cometd._debug('Timing out remote call', message, 'after', timeout, 'ms');\n\n          _failMessage({\n            id: message.id,\n            error: '406::timeout',\n            successful: false,\n            failure: {\n              message: message,\n              reason: 'Remote Call Timeout'\n            }\n          });\n        }, timeout);\n\n        _cometd._debug('Scheduled remote call timeout', message, 'in', timeout, 'ms');\n      }\n\n      _remoteCalls[message.id] = context;\n\n      _queueSend(message);\n    };\n\n    this.remoteCallBinary = function (target, data, last, meta, timeout, callback) {\n      if (_isFunction(data)) {\n        callback = data;\n        data = new ArrayBuffer(0);\n        last = true;\n        meta = undefined;\n        timeout = _config.maxNetworkDelay;\n      } else if (_isFunction(last)) {\n        callback = last;\n        last = true;\n        meta = undefined;\n        timeout = _config.maxNetworkDelay;\n      } else if (_isFunction(meta)) {\n        callback = meta;\n        meta = undefined;\n        timeout = _config.maxNetworkDelay;\n      } else if (_isFunction(timeout)) {\n        callback = timeout;\n        timeout = _config.maxNetworkDelay;\n      }\n\n      var content = {\n        meta: meta,\n        data: data,\n        last: last\n      };\n      var ext = {\n        ext: {\n          binary: {}\n        }\n      };\n      this.remoteCall(target, content, timeout, ext, callback);\n    };\n    /**\n     * Returns a string representing the status of the bayeux communication with the Bayeux server.\n     */\n\n\n    this.getStatus = function () {\n      return _status;\n    };\n    /**\n     * Returns whether this instance has been disconnected.\n     */\n\n\n    this.isDisconnected = _isDisconnected;\n    /**\n     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * Default value is 1 second, which means if there is a persistent failure the retries will happen\n     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n     * @param period the backoff period to set\n     * @see #getBackoffIncrement()\n     */\n\n    this.setBackoffIncrement = function (period) {\n      _config.backoffIncrement = period;\n    };\n    /**\n     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * @see #setBackoffIncrement(period)\n     */\n\n\n    this.getBackoffIncrement = function () {\n      return _config.backoffIncrement;\n    };\n    /**\n     * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n     */\n\n\n    this.getBackoffPeriod = function () {\n      return _backoff;\n    };\n    /**\n     * Increases the backoff period up to the maximum value configured.\n     * @returns the backoff period after increment\n     * @see getBackoffIncrement\n     */\n\n\n    this.increaseBackoffPeriod = function () {\n      return _increaseBackoff();\n    };\n    /**\n     * Resets the backoff period to zero.\n     */\n\n\n    this.resetBackoffPeriod = function () {\n      _resetBackoff();\n    };\n    /**\n     * Sets the log level for console logging.\n     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n     * less verbose to more verbose.\n     * @param level the log level string\n     */\n\n\n    this.setLogLevel = function (level) {\n      _config.logLevel = level;\n    };\n    /**\n     * Registers an extension whose callbacks are called for every incoming message\n     * (that comes from the server to this client implementation) and for every\n     * outgoing message (that originates from this client implementation for the\n     * server).\n     * The format of the extension object is the following:\n     * <pre>\n     * {\n     *     incoming: function(message) { ... },\n     *     outgoing: function(message) { ... }\n     * }\n     * </pre>\n     * Both properties are optional, but if they are present they will be called\n     * respectively for each incoming message and for each outgoing message.\n     * @param name the name of the extension\n     * @param extension the extension to register\n     * @return true if the extension was registered, false otherwise\n     * @see #unregisterExtension(name)\n     */\n\n\n    this.registerExtension = function (name, extension) {\n      if (arguments.length < 2) {\n        throw 'Illegal arguments number: required 2, got ' + arguments.length;\n      }\n\n      if (!_isString(name)) {\n        throw 'Illegal argument type: extension name must be a string';\n      }\n\n      var existing = false;\n\n      for (var i = 0; i < _extensions.length; ++i) {\n        var existingExtension = _extensions[i];\n\n        if (existingExtension.name === name) {\n          existing = true;\n          break;\n        }\n      }\n\n      if (!existing) {\n        _extensions.push({\n          name: name,\n          extension: extension\n        });\n\n        this._debug('Registered extension', name); // Callback for extensions\n\n\n        if (_isFunction(extension.registered)) {\n          extension.registered(name, this);\n        }\n\n        return true;\n      } else {\n        this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n\n        return false;\n      }\n    };\n    /**\n     * Unregister an extension previously registered with\n     * {@link #registerExtension(name, extension)}.\n     * @param name the name of the extension to unregister.\n     * @return true if the extension was unregistered, false otherwise\n     */\n\n\n    this.unregisterExtension = function (name) {\n      if (!_isString(name)) {\n        throw 'Illegal argument type: extension name must be a string';\n      }\n\n      var unregistered = false;\n\n      for (var i = 0; i < _extensions.length; ++i) {\n        var extension = _extensions[i];\n\n        if (extension.name === name) {\n          _extensions.splice(i, 1);\n\n          unregistered = true;\n\n          this._debug('Unregistered extension', name); // Callback for extensions\n\n\n          var ext = extension.extension;\n\n          if (_isFunction(ext.unregistered)) {\n            ext.unregistered();\n          }\n\n          break;\n        }\n      }\n\n      return unregistered;\n    };\n    /**\n     * Find the extension registered with the given name.\n     * @param name the name of the extension to find\n     * @return the extension found or null if no extension with the given name has been registered\n     */\n\n\n    this.getExtension = function (name) {\n      for (var i = 0; i < _extensions.length; ++i) {\n        var extension = _extensions[i];\n\n        if (extension.name === name) {\n          return extension.extension;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Returns the name assigned to this CometD object, or the string 'default'\n     * if no name has been explicitly passed as parameter to the constructor.\n     */\n\n\n    this.getName = function () {\n      return _name;\n    };\n    /**\n     * Returns the clientId assigned by the Bayeux server during handshake.\n     */\n\n\n    this.getClientId = function () {\n      return _clientId;\n    };\n    /**\n     * Returns the URL of the Bayeux server.\n     */\n\n\n    this.getURL = function () {\n      if (_transport) {\n        var url = _transport.getURL();\n\n        if (url) {\n          return url;\n        }\n\n        url = _config.urls[_transport.getType()];\n\n        if (url) {\n          return url;\n        }\n      }\n\n      return _config.url;\n    };\n\n    this.getTransport = function () {\n      return _transport;\n    };\n\n    this.getConfiguration = function () {\n      return this._mixin(true, {}, _config);\n    };\n\n    this.getAdvice = function () {\n      return this._mixin(true, {}, _advice);\n    };\n\n    this.setTimeout = function (funktion, delay) {\n      return _scheduler.setTimeout(function () {\n        try {\n          _cometd._debug('Invoking timed function', funktion);\n\n          funktion();\n        } catch (x) {\n          _cometd._debug('Exception invoking timed function', funktion, x);\n        }\n      }, delay);\n    };\n\n    this.clearTimeout = function (id) {\n      _scheduler.clearTimeout(id);\n    }; // Initialize transports.\n\n\n    if (runtime.WebSocket) {\n      this.registerTransport('websocket', new WebSocketTransport());\n    }\n\n    this.registerTransport('long-polling', new LongPollingTransport());\n    this.registerTransport('callback-polling', new CallbackPollingTransport());\n  };\n\n  var _z85EncodeTable = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '.', '-', ':', '+', '=', '^', '!', '/', '*', '?', '&', '<', '>', '(', ')', '[', ']', '{', '}', '@', '%', '$', '#'];\n  var _z85DecodeTable = [0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00, 0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47, 0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00, 0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00];\n  var Z85 = {\n    encode: function (bytes) {\n      var buffer = null;\n\n      if (bytes instanceof ArrayBuffer) {\n        buffer = bytes;\n      } else if (bytes.buffer instanceof ArrayBuffer) {\n        buffer = bytes.buffer;\n      } else if (Array.isArray(bytes)) {\n        buffer = new Uint8Array(bytes).buffer;\n      }\n\n      if (buffer == null) {\n        throw 'Cannot Z85 encode ' + bytes;\n      }\n\n      var length = buffer.byteLength;\n      var remainder = length % 4;\n      var padding = 4 - (remainder === 0 ? 4 : remainder);\n      var view = new DataView(buffer);\n      var result = '';\n      var value = 0;\n\n      for (var i = 0; i < length + padding; ++i) {\n        var isPadding = i >= length;\n        value = value * 256 + (isPadding ? 0 : view.getUint8(i));\n\n        if ((i + 1) % 4 === 0) {\n          var divisor = 85 * 85 * 85 * 85;\n\n          for (var j = 5; j > 0; --j) {\n            if (!isPadding || j > padding) {\n              var code = Math.floor(value / divisor) % 85;\n              result += _z85EncodeTable[code];\n            }\n\n            divisor /= 85;\n          }\n\n          value = 0;\n        }\n      }\n\n      return result;\n    },\n    decode: function (string) {\n      var remainder = string.length % 5;\n      var padding = 5 - (remainder === 0 ? 5 : remainder);\n\n      for (var p = 0; p < padding; ++p) {\n        string += _z85EncodeTable[_z85EncodeTable.length - 1];\n      }\n\n      var length = string.length;\n      var buffer = new ArrayBuffer(length * 4 / 5 - padding);\n      var view = new DataView(buffer);\n      var value = 0;\n      var charIdx = 0;\n      var byteIdx = 0;\n\n      for (var i = 0; i < length; ++i) {\n        var code = string.charCodeAt(charIdx++) - 32;\n        value = value * 85 + _z85DecodeTable[code];\n\n        if (charIdx % 5 === 0) {\n          var divisor = 256 * 256 * 256;\n\n          while (divisor >= 1) {\n            if (byteIdx < view.byteLength) {\n              view.setUint8(byteIdx++, Math.floor(value / divisor) % 256);\n            }\n\n            divisor /= 256;\n          }\n\n          value = 0;\n        }\n      }\n\n      return buffer;\n    }\n  };\n  return {\n    CometD: CometD,\n    Transport: Transport,\n    RequestTransport: RequestTransport,\n    LongPollingTransport: LongPollingTransport,\n    CallbackPollingTransport: CallbackPollingTransport,\n    WebSocketTransport: WebSocketTransport,\n    Utils: Utils,\n    Z85: Z85\n  };\n});","map":null,"metadata":{},"sourceType":"script"}